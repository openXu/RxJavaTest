# 前言

在项目开发中，通常会遇到流式业务链，比如：

```Java
//登录页面
//1. 检查网络是否可用
if(可用){
    //2. 验证用户名密码
    if(验证成功){
        //3. 刷新DeviceToken
        if(刷新成功){
            //4. 登录成功跳转
        }else{
             Toast.makeText("刷新DeviceToken失败")
        }   
    }else{
        Toast.makeText("用户名密码错误")
    }   
}else{
    Toast.makeText("网络不可用")
}

//三级缓存
内存中获取->磁盘获取->服务器获取
```

使用大量的`if else`判断导致代码层级太深，形成三角形代码，本来业务链是线性的，一件事处理完再进行下一条，有没有办法写代码也使用线性（链式）调用？

**思想：**前面一个事件的结果（是否成功）被后面盯梢，如果成功则执行下一个事件，否则后面的事件都不执行，可以采用观察者模式实现。观察者核心思想是被观察者持有观察者的引用，当被观察者中的事件发生变化时通知观察者。

[响应式编程的思想](https://www.jianshu.com/p/c95e29854cb1)

> 响应式的思想就是，希望有某种方式来为两个事件构建关系，而不是通过ifelse命令式判断。在开发App时，每一个页面的交互及一系列业务逻辑之间都存在关系，我们的开发就是在构建一系列的业务逻辑之间的关系。
>
> 但是主流的编程并不支持这种构建关系，知道出现Rx和一些其他支持这种思想的框架才真正把响应式编程引入实际代码开发中。
>
> Rx是响应式拓展，即支持响应式编程的一种拓展,为响应式在不同语言中的实现提供指导思想

## 响应式编程

响应式编程是一种**通过异步和数据流来构建事务关系的编程模型**。“事务的关系”是响应式编程的核心理念，“数据流”和“异步”是实现这个核心理念的关键。异步是为了将事务抽取隔离，而数据流(事件流)是为了将事务联系起来，是事务之间沟通的桥梁。

# 基本实现

## 设计模式

设计模式基于六大原则

- 单一职责原则：一个类只做一件事，一个类应该只有一个引起它修改的原因
- 开闭原则：一个软件实体如类、模块和函数应该对修改封闭，对扩展开放
- 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能
- 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节。把抽象层放在程序设计的高层，并保持稳定，程序的细节变化由低层的实现层来完成。
- 迪米特法则：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话
- 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。

所有的设计模式都是为了程序能更好的满足这六大原则

核心设计模式：

- 观察者模式

> 观察者模式是一种对象行为模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。在观察者模式中，主题是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅并接收通知。

- 装饰器模式

核心设计模式如何发生变种

- 观察者模式实现链式调度
- 装饰器模式实现事件变换

## 观察者模式的实现

ObservableSource (被观察者) 

Observer (观察者) 


# RxJava高级实战

## 自定义操作符实现线程切换

## RxBus框架设计

## 自定义Rxbinding实现功能防抖

## 自定义Observer实现JavaBean分离处理

















