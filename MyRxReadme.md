# 前言

在项目开发中，通常会遇到流式业务链，比如：

```Java
//登录页面
//1. 检查网络是否可用
if(可用){
    //2. 验证用户名密码
    if(验证成功){
        //3. 刷新DeviceToken
        if(刷新成功){
            //4. 登录成功跳转
        }else{
             Toast.makeText("刷新DeviceToken失败")
        }   
    }else{
        Toast.makeText("用户名密码错误")
    }   
}else{
    Toast.makeText("网络不可用")
}

//三级缓存
内存中获取->磁盘获取->服务器获取
```

使用大量的`if else`判断导致代码层级太深，形成三角形代码，本来业务链是线性的，一件事处理完再进行下一条，有没有办法写代码也使用线性（链式）调用？

## RxJava现状

网上RxJava相关的教程资料水平都参差不齐，刚开始很难鉴别哪些人说的是对的哪些人说的是错误的，很多教程在自己没有精通的情况下，就会将别人带入沟中。

对于初学者，可能就直接对着某篇文章一个个的学习RxJava中的操作符，搞清楚这些操作符是什么意思，提供什么样的功能，然而花了大量时间学了上百个操作符，最后在实际开发过程中却一个也不会用，根本不知道怎样将RxJava引入到开发中（包括我自己），这是根本没搞明白RxJava的核心设计和思想。

Rx是一种响应式编程模型，**通过异步和数据流来构建事务关系的编程模型**。“事务的关系”是响应式编程的核心理念，“数据流”和“异步”是实现这个核心理念的关键。异步是为了将事务抽取隔离，而数据流(事件流)是为了将事务联系起来，是事务之间沟通的桥梁。

**思想：**前面一个事件的结果（是否成功）被后面盯梢，如果成功则执行下一个事件，否则后面的事件都不执行，可以采用观察者模式实现。观察者核心思想是被观察者持有观察者的引用，当被观察者中的事件发生变化时通知观察者。

[响应式编程的思想](https://www.jianshu.com/p/c95e29854cb1)

> 响应式的思想就是，希望有某种方式来为两个事件构建关系，而不是通过ifelse命令式判断。在开发App时，每一个页面的交互及一系列业务逻辑之间都存在关系，我们的开发就是在构建一系列的业务逻辑之间的关系。
>
> 但是主流的编程并不支持这种构建关系，知道出现Rx和一些其他支持这种思想的框架才真正把响应式编程引入实际代码开发中。
>
> Rx是响应式拓展，即支持响应式编程的一种拓展,为响应式在不同语言中的实现提供指导思想

# 基本实现

## 需求分析

我们的目的是为了实现流式业务链的线性调用，所以能大概推测出最终的调用格式：

```Java

```


## 设计模式

设计模式基于六大原则，所有的设计模式都是为了程序能更好的满足这六大原则

1. 单一职责原则：一个类只做一件事
2. 开闭原则：类、模块和函数应该对修改封闭，对扩展开放
3. 里氏替换原则：子类应该可以完全替换父类。也就是说在使用继承时，只扩展新功能，而不要破坏父类原有的功能
4. 依赖倒置原则：细节应该依赖于抽象，抽象不应依赖于细节，两个类之间的关联应该由接口关联起来
5. 迪米特法则：又名「最少知道原则」，一个类不应知道自己操作的类的细节，换言之，只和朋友谈话，不和朋友的朋友谈话
6. 接口隔离原则：客户端不应依赖它不需要的接口。如果一个接口在实现时，部分方法由于冗余被客户端空实现，则应该将接口拆分，让实现类只需依赖自己需要的接口方法。

使用到的核心设计模式：

- 观察者模式

> 观察者模式是一种对象行为模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。

- 装饰器模式

> 装饰器模式可以动态的给一个对象添加一些额外的功能，将需要添加的额外功能划分为最小的粒度，装饰器模式能使得这些最小粒度功能的自由组合，避免传统继承扩展的方式导致类的爆炸

在框架设计过程中对设计模式进行变种，从而使得观察者模式实现链式调度，装饰器模式实现事件变换

## 手写RxJava

1. 被观察者

```Java
//被观察者抽象接口，提供订阅功能
ObservableSource 
//被观察者对外暴露的接口，主要用于提供一些列静态方法创建被观察者对象
//并提供一些操作符方法，操作符方法返回一个新的被观察者装饰类，对原被观察者进行功能的扩展
Observable 
//真正的被观察者实现类，通过Emitter提供发射数据给观察者的能力
ObservableCreate 
```

2. 发射器

```Java
//发射器抽象接口，提供给观察者发送数据的能力（通知观察者）
Emitter 
//发射器具体实现类，调用观察者的回调方法
CreateEmitter 
//用于关联Observable和Emitter的接口，可在该接口的方法中处理业务数据，并发射数据给观察者
ObservableOnSubscribe 
```

3. 观察者

```Java
//观察者抽象接口，接受被观察者发射的数据
Observer  
```

4. 装饰被观察者

```Java
AbstractObservableWithUpStream 被观察者的装饰类，它维护了上游的被观察者对象
ObservableMap 装饰上游被观察者，新增功能：创建一个新的观察者接收上游数据
```

5. 装饰观察者

```Java
BasicFuseableObserver 观察者的装饰类，它维护了下游的观察者对象
MapObserver 装饰下游观察者，新增功能：订阅上游被观察者接收上游数据，通过Function函数对数据处理后发送给下游观察者
```

## 事件和数据流分析

```Java
Observable.create(new ObservableOnSubscribe<String>() {
    @Override
    public void subscribe(ObservableEmitter<String> emitter) throws Exception {
        emitter.onNext("上游数据");
    }
}).map(new Function<String, Boolean>() {
    @Override
    public Boolean apply(String s) throws Exception {
        System.out.println("收到上游被观察这发射的数据->"+s);
        System.out.println("对数据进行处理->"+s.contains("数据"));
        return s.contains("数据");
    }
}).subscribe(new Observer<Boolean>() {
    @Override
    public void onSubscribe(Disposable d) {
    }
    @Override
    public void onNext(Boolean b) {
        System.out.println("下游观察者收到数据->"+b);
    }
    @Override
    public void onError(Throwable e) {
    }
    @Override
    public void onComplete() {
    }
});
```





















# RxJava高级实战

## 自定义操作符实现线程切换

## RxBus框架设计

## 自定义Rxbinding实现功能防抖

## 自定义Observer实现JavaBean分离处理

















